---
title: Ynoi 做题记录
tags: 数据结构 Ynoi
---

# Ynoi 做题记录

Latest Updated on: 2021.3.10

总计：31

## [Ynoi2008] rplexq

### 题意

给定一棵有根树，每次询问 $l,r,x$，查询 $\sum\limits_{i=l}^r\sum\limits_{j=l+1}^r[\operatorname{lca}(i,j)=x]$。

### 题解

考虑对 $x$ 的儿子数根号分治。

- 小于等于 $\sqrt n$，对于这样的节点，使用分块进行二维数点，求出每个子树在区间 $l,r$ 内的节点数量 ，复杂度为 $O((n+m)\sqrt n)$。

- 大于 $\sqrt n$，对于这样的节点，我们枚举儿子 $v$，遍历这棵子树，将所有节点标记上 $v$，发现 $x$ 字数内不合法的方案数类似于小 Z 的袜子，可以用莫队维护，复杂度为 $O(\sum n_i\sqrt m_i)$。其中 $\sum m_i=O(m)$，$n_i=O(n),\sum n_i=O(n\sqrt n)$，复杂度显然不对，我们希望一个点只出现在一次莫队中，这样 $\sum n_i=O(n)$，总复杂度即为 $O(n\sqrt m)$。

	考虑按 dfs 序倒序处理，保证 $x$ 处理时子树内儿子数量大于 $\sqrt n$ 的节点已被处理。

	我们将 $x$ 的子树分为两类，一类是没有节点被访问过的，一类是存在节点被访问过的。

	对于未被访问的节点，跑离散化莫队；对于访问过的节点，显然包括这种节点的子树不超过 $O(\sqrt n)$ 个，使用分块对这些子树分别维护一下即可。

	最后再进行一次 $O((n+m)\log n)$ 的二维数点得到总情况数减掉算出来的非法方案数就是答案了。

## [Ynoi2008] rrusq

### 题意

给定 $n$ 个关键点，$m$ 个矩形，在同一个二维平面上，每个关键点有权值，每次查询一个区间 $l,r$，求矩形 $l\sim r$ 的并覆盖到的关键点权值和。

### 题解

一个常用套路，把询问离线下来，按照 HH 的项链的做法，向右挪动右端点，用一种数据结构维护左端点在不同位置的答案。对于一个关键点，我们只在最靠右的覆盖它的矩形处统计，使用 $\rm{KDT}$ 维护点，对于每个矩形打上标记，遇到已经打上标记的点，将标记收回，这里的复杂度显然是 $O(m\sqrt n)$ ，也就是说，我们维护答案的数据结构会收到 $O(m\sqrt n)$ 次修改，$O(q)$ 次询问，使用分块维护。

## [Ynoi2009] rprsvq

### 题意

给定一个长为 $n$ 的序列，支持两种操作：

- 区间加；
- 区间中所有子序列的方差和。

### 题解

一个序列的方差为：


$$
\begin{aligned}
&\frac{1}{n}\sum\limits_{i=1}^{n}(a_i-\overline{a})^2\\
=&\frac{1}{n}\sum\limits_{i=1}^{n}(a_i^2-2a_i\overline{a}+\overline{a}^2)\\
=&\frac{1}{n}\sum\limits_{i=1}^{n}a_i^2-\frac{2\overline{a}}{n}\sum\limits_{i=1}^{n}a_i+\overline{a}^2\\
=&\frac{1}{n}\sum\limits_{i=1}^{n}a_i^2-\overline{a}^2\\
=&\frac{1}{n}\sum\limits_{i=1}^{n}a_i^2-\frac{1}{n^2}(\sum\limits_{i=1}^na_i)^2\\
=&\frac{n-1}{n^2}\sum\limits_{i=1}^{n}a_i^2-\frac{2}{n^2}\sum\limits_{i=1}^n\sum\limits_{j=i+1}^na_ia_j\\
\end{aligned}
$$


那么，对于一个区间的答案就是：


$$
\begin{aligned}
&\sum\limits_{n=2}^{r-l+1}(\frac{n-1}{n^2}\binom{r-l}{n-1}\sum\limits_{i=l}^{r}a_i^2-\frac{2}{n^2}\binom{r-l-1}{n-2}\sum\limits_{i=l}^r\sum\limits_{j=i+1}^ra_ia_j)\\
=&\sum\limits_{n=2}^{r-l+1}\frac{1}{n^2}(\binom{r-l-1}{n-2}(r-l)\sum\limits_{i=l}^{r}a_i^2-2\binom{r-l-1}{n-2}\sum\limits_{i=l}^r\sum\limits_{j=i+1}^ra_ia_j)\\
=&\sum\limits_{n=2}^{r-l+1}\frac{1}{n^2}\binom{r-l-1}{n-2}((r-l)\sum\limits_{i=l}^{r}a_i^2-2\sum\limits_{i=l}^r\sum\limits_{j=i+1}^ra_ia_j)\\
=&((r-l)\sum\limits_{i=l}^{r}a_i^2-2\sum\limits_{i=l}^r\sum\limits_{j=i+1}^ra_ia_j)\sum\limits_{n=2}^{r-l+1}\frac{1}{n^2}\binom{r-l-1}{n-2}\\
=&((r-l+1)\sum\limits_{i=l}^{r}a_i^2-(\sum\limits_{i=l}^ra_i)^2)\sum\limits_{n=2}^{r-l+1}\frac{1}{n^2}\binom{r-l-1}{n-2}\\
\end{aligned}
$$


前面的东西可以用线段树维护，后面的东西继续推：


$$
\begin{aligned}
&\sum\limits_{n=2}^{x}\frac{\binom{x-2}{n-2}}{n^2}\\
=&\sum\limits_{n=2}^{x}\frac{\binom{x-2}{n-2}\binom{x}{2}}{n^2\binom{x}{2}}\\
=&\sum\limits_{n=2}^{x}\frac{\binom{x}{n}\binom{n}{2}}{n^2\binom{x}{2}}\\
=&\frac{1}{x(x-1)}\sum\limits_{n=2}^{x}\frac{\binom{x}{n}(n-1)}{n}\\
\end{aligned}
$$



设 $f_{x}=\sum\limits_{n=1}^{x}\frac{\binom{x}{n}(n-1)}{n}$。


$$
\begin{aligned}
f_x=&\sum\limits_{n=1}^{x}\frac{\binom{x}{n}(n-1)}{n}\\
=&\sum\limits_{n=1}^{x}\frac{(\binom{x-1}{n}+\binom{x-1}{n-1})(n-1)}{n}\\
=&\sum\limits_{n=1}^{x-1}\frac{\binom{x-1}{n}(n-1)}{n}+\sum\limits_{n=1}^{x}\frac{\binom{x-1}{n-1}(n-1)}{n}\\
=&f_{x-1}+\sum\limits_{n=1}^{x}\binom{x-1}{n-1}-\sum\limits_{n=1}^{x}\frac{\binom{x-1}{n-1}}{n}\\
=&f_{x-1}+2^{x-1}-\sum\limits_{n=0}^{x-1}\frac{\binom{x-1}{n}}{n+1}\\
=&f_{x-1}+2^{x-1}-\sum\limits_{n=0}^{x-1}\frac{\binom{x}{n+1}}{x}\\
=&f_{x-1}+2^{x-1}-\frac{2^x-1}{x}\\
\end{aligned}
$$


推到这里就可以 $O(n)$ 预处理系数了。

## [Ynoi2010] Fusion tree

### 题意

给定一棵树，点有点权，要求支持下列操作：

- 将与 $x$ 距离为 $1$ 的点点权 $+1$；
- 将 $x$ 点权 $-v$；
- 询问与 $x$ 距离为 $1$ 的点点权的异或和。

### 题解

对于这种题，我们有一个套路是在每个节点处开一个数据结构维护子节点信息，那么这个数据结构需要支持单独修改一个值，给所有值加一，求所有值的异或和三种操作。我们倒着把数按二进制位插入 $\rm{trie}$ 中显然可以做到第一种和第三种操作，考虑第二种操作，从根节点出发，每次交换左右子树，再进入交换后的 $0$ 子树，记得处理进位。还需要记得维护单点的值，这部分随便处理一下即可。

## [Ynoi2010] y-fast trie

### 题意

给定一个常数 $C$，需要维护一个集合 $S$，每次操作插入或删除一个元素并输出 $\max\limits_{i,j\in S,i\ne j}\left((i+j)\bmod C\right)$。

### 题解

所有元素 $\bmod C$  后加入 `multiset`，维护与它的和最接近 $C$ 的元素，并更新答案，最终答案为维护的答案和最大的两个元素和取 $\max$，注意 `std::multiset::count()` 的复杂度为 $O(\log n+cnt)$。

## [Ynoi2011] 初始化

### 题意

给定一个长为 $n$ 的序列 $A$，支持以下操作：

- 给定 $a,b,v$，对所有满足 $k\equiv a\pmod b$ 的 $k$，$A_k=A_k+v$；
- 区间求和。

### 题解

显然，当 $b\ge \sqrt n$ 时，暴力修改每个点的复杂度正确，使用 $O(1)$ 修改，$O(\sqrt n)$ 查询的分块维护区间和；对于小于 $\sqrt n$ 的 $b$ 我们考虑对于每一个 $b$ 开一个关于 $a$ 的前缀和记录答案，修改时遍历从 $a$ 开始的前缀和数组并对每一个元素进行修改，复杂度 $O(\sqrt n)$，查询时遍历每一个 $b$，$O(1)$ 计算答案。

## [Ynoi2011] 遥远的过去

### 题意

定义 Z 语言：

* 字符集非常大，甚至可能有 $2147483648(2 ^ {31})$ 种字符；
* 每个单词由一系列**两两不同**的字符组成；
* 字符既能比较相同和不同，也能比较大小，因此之后我们用数字来表示 Z 语言中稀奇古怪的字符；
* 两个看起来完全不同的单词也可能是同一个单词，因为：只要两个单词中第 K 大的字符所在的位置相同，那么其实就是本质上相同的单词。例如 $\{1, 2, 3, 4, 5\}$ 与 $\{2, 3, 23, 233, 23333\}$ 是相同的。（所以你可以用 Z 语言很方便地加密信息！）

给定两个 Z 语言字符串 $A,B$ 每次单点修改 $B$，询问 $B$ 在 $A$ 中的出现次数。

### 题解

平衡树维护哈希值，随便搞搞就行了，我的哈希值定义为 $\sum\limits_{i=1}^mrank_i\mathrm{base}^{pos_i}$，单哈希会被卡，双哈希能过。

## [Ynoi2011] 成都七中

### 题意

给定一棵 $n$ 个节点的树，每个节点有一种颜色，每次询问给出 $l,r,x$，求只保留编号在 $[l,r]$ 中的节点时，$x$ 所在连通块的颜色数。

### 题解

建立点分树，树上任意一个连通块中一定存在一个点满足连通块内元素在其在点分树上的子树内，知道这个性质后，我们便可以把询问放在这个节点上，问题转化为在一棵树上，求从根节点出发，只经过 $[l,r]$ 内的点，能到达的颜色数。我们记录点分树上每一个节点到每一个祖先路径编号的最大最小值 $L,R$ 显然只有 $l\le L\le R\le r$ 才会对答案产生贡献。一个熟练的 oier 会发现这是一道二维偏序水题，先对节点信息和询问信息的 $r$ 排序，在用树状数组维护每种颜色 $l$ 的最大值即可。

## [Ynoi2011] 竞赛实验班

### 题意

维护一个数组 $A$：

- 在数组末尾插入 $x$；
- 输出 $\sum\limits_{i=l}^rA_i$；
- 将所有数异或上 $x$；
- 将 $A$ 从小到大排序。

### 题解

显然，任意时刻数组的形态都是一个排好序的数组异或上一个数后面接上一些数。维护一个全局异或值，将新插入的数异或上该值再插入。对于排好序的段，使用 $\rm{trie}$ 维护；对于未排序段，拆位计算贡献。每次排序操作，将原未排序段插入 $\rm{trie}$ 中，根据全局异或值维护 $\rm{trie}$ 翻转标记。

## [Ynoi2012] 惊惶的 SCOI2016

### 题意

给定一棵 $n$ 个点的树，每个点有颜色，$m$ 次修改单点的颜色，每次修改后输出所有有向简单路径的颜色数量的和。

### 题解

考虑单独统计每种颜色的贡献，对于每种颜色，我们认为这种颜色为白色，其他颜色为黑色，经过它的路径数量为 $n^2-\sum\text{黑色连通块大小}^2$，用 $\text{Qtree6}$ 的方法维护即可。

## [Ynoi2012] NOIP2016 人生巅峰

### 题意

给定一个长为 $n$ 的序列和一个常数 $v$，有两种操作：

- 对于区间 $l,r$ 内的所有数，变为 $a_i^3\bmod v$；
- 询问区间 $l,r$ 内能否选出两个下标的不交非空集合使得两个集合贡献相等，一个元素对集合的贡献为 $a_i+1$。

### 题解

因为 $2^{14}-1>14000$，根据抽屉原理，如果询问区间大于 $13$ 则一定有解，我们只考虑询问区间小于等于 $13$ 的的询问。

对于修改，树状数组维护每个数立方了几次，询问时算出区间内数的实际值即可。

用 `bitset` 优化背包即可通过小于等于 $13$ 的询问。时间复杂度 $O(m\frac{13^2v}{w})$。

## [Ynoi2013] 无力回天 NOI2017

### 题意

维护一个序列 $a$，支持两种操作：

- 对于区间 $[l,r]$ 内的每一个数 $a_i$，$a_i=a_i\operatorname{xor} v$；
- 求在区间 $[l,r]$ 内任选任意个（包括 $0$ 个）数 $\operatorname{xor}$ 起来，这个值与 $v$ 的最大异或和。

### 题解

用树状数组维护区间异或单点查询，再用线段树维护差分数组的区间线性基，查询时取出 $[l+1,r]$ 的线性基，插入 $a_l$ 后得到的线性基与原数组中 $[l,r]$ 的线性基等价，直接查询即可。

## [Ynoi2013] 对数据结构的爱

### 题意

给定一个序列 $a$，每次查询 `Sum(a,l,r,p)` 的运行结果。

![](https://missingroom.github.io/assets/image/P5609.png)

### 题解

一个数通过一个区间的时候，$-p$ 的次数随这个数的增大单调递增，线段树双指针合并一下就好了，查询的时候二分即可。

## [Ynoi2013] 大学

### 题意

维护一个序列 $a$，支持两种操作：

- 把区间 $[l,r]$ 内的每一个 $x$ 的倍数除以 $x$；
- 求区间 $[l,r]$ 的和。

### 题解

对于每一个数开一个 `std::vector` 存储所有倍数的位置，用并查集维护 $\rm{nxt}$ 数组，树状数组维护区间和，每次修改都暴力在树状数组里修改，注意判掉 $x=1$ 的情况。

## [Ynoi2013] D2T2

### 题意

给定一个序列，每次查询将值在 $[L,R]$ 内的值保留不变，其他值变成 $0$，求区间 $[l,r]$ 内的最大子段和，询问独立。

### 题解

对于一个长为 $n$ 的序列，本质不同的值域区间数量为 $O(n^2)$，考虑分治，我们显然有一种 $T(n)=2T(\frac{n}{2})+O(n^2)=O(n^2)$ 的分治方法求出在所有值域限制下的信息（指最大前缀和、最大后缀和、区间和、最大子段和）。对序列分块，每一块都这么处理，并统计对询问的贡献，实现上注意要使用双指针而不是二分。

## [Ynoi2015] 我回来了

### 题意

亵渎描述为：等概率随机在 $[l,r]$ 中选出一个整数作为伤害值 $d$，对所有随从造成 $d$ 点伤害，如果有随从死亡，则再次施放该法术，但伤害值不重新随机；如果没有随从死亡，则停止释放。

支持两种操作：

- 在场面上加入一个血量为 $h$ 的随从，这里随从的血量都不能超过 $n$；
- 给定 $l,r$，询问亵渎期望触发多少次，答案乘 $r-l+1$ 输出。

### 题解

注意到期望乘 $r-l+1$ 其实就是 $d$ 取 $[l,r]$ 内每一个整数时释放次数的和，当 $d$ 固定时，求的就是最小的 $i$ 使得血量为 $[(i-1)d+1,id]$ 的随从均不存在。

求出每个血量的随从第一次被加入的时间，上面的区间只有 $O(n\log n)$ 种（调和级数），所以我们可以用 $O(n\log n)-O(1)$ 的 ST 表求出每个区间第一次有随从的时间，再对相同长度的区间求前缀 $\max$，在这个值后，这段区间才会产生贡献，树状数组维护即可。

## [Ynoi2015] 即便看不到未来

### 题意

给定一个序列，每次查询一段区间内长度为 $1,2,\dots,10$ 的极长值域连续段分别有多少个，极长值域连续段 $[l,r]$ 满足条件 $[l,r]$ 内的所有数都出现在这个区间内，$l-1,r+1$ 没有出现在这个区间内，它的长度是 $r-l+1$。

### 题解

考虑扫描线，对于右端点相同的询问，使用数据结构维护不同左端点处的答案。每加入一个数，只用考虑这个值前后各 $10$ 个值，把这些值最靠右的出现位置记下来，从右往左扫过去，更新答案即可。

## [Ynoi2015] 此时此刻的光辉

### 题意

给定一个序列，每次查询区间乘积的约数个数 $\bmod 19260817$ 的结果。

### 题解

考虑莫队，这题显然有一个 $O(n\sqrt m\log a)$ 的暴力，我们考虑将小于 $1000$ 的质数出现次数的前缀和预处理出来，这样每个数只剩最多两个质因子了，莫队时候维护即可。

## [Ynoi2015] 盼君勿忘

### 题意

给定一个序列，每次查询区间 $[l,r]$ 内所有子序列分别去重后的和 $\bmod p$，注意：每次询问 $p$ 不同。

### 题解

在区间 $[l,r]$ 内，$k$ 出现了 $cnt_k$ 次，则它对答案的贡献为 $k(2^{r-l+1}-2^{r-l+1-cnt_k})$，不同的出现次数只有 $O(\sqrt n)$ 种，所以直接莫队，暴力光速幂计算答案即可。

## [Ynoi2016] 掉进兔子洞

### 题意

给定一个序列，每次询问三个区间，把重复的数一个一个地删除，求剩余数的个数。

### 题解

直接莫队，离散化之后上 `bitset`，答案就是三个区间 `bitset` 的与和的 $1$ 的数量。

## [Ynoi2016] 这是我自己的发明

### 题意

给定一棵树，有点权，支持两种操作：

- 换根；
- 从 $x$ 的子树中选每一个点，从 $y$ 的子树中选每一个点，求点权相等的情况数。

### 题解

倍长 $\text{dfn}$，换根是假的，每个子树对应一个区间，问题转化为从 $[l_1,r_1]$ 中选每一个数，从 $[l_2,r_2]$ 中选每一个数，数相等的情况数，设答案为 $f([l_1,r_1],[l_2,r_2])$，$f([l_1,r_1],[l_2,r_2])=f([1,r_1],[1,r_2])-f([1,l_1-1],[1,r_2])-f([1,r_1],[1,l_2-1])+f([1,l_1-1],[1,l_2-1])$，问题转化为求 $f([1,a],[1,b])$，像莫队一样移动 $a,b$ 两个指针并统计答案即可。

## [Ynoi2016] 炸脖龙 I

### 题意

给定一个序列，支持两种操作：

- 区间 $[l,r]$ 加 $x$；
- 查询 $a_l^{a_{l+1}^{\dots^{a_{r}}}}\bmod p$。

### 题解

树状数组维护区间加单点查询，对于询问，用扩展欧拉定理降幂，一个 $\text{dfs}$ 完事，记得筛 $\varphi$。

## [Ynoi2017] 由乃的 OJ

### 题意

给你一个有 $n$ 个点的树，每个点的包括一个位运算 $opt$ 和一个权值 $x$，位运算有三种 `&`、`|`、`^`，分别用 $1,2,3$ 表示。

每次询问包含三个整数 $x,y,z$，初始选定一个数 $v$。然后 $v$ 依次经过从 $x$ 到 $y$ 的所有节点，每经过一个点 $i$，$v$ 就变成 $v\ opt_i\ x_i$，所以他想问你，最后到 $y$ 时，希望得到的值尽可能大，求最大值。给定的初始值 $v$ 必须是在 $[0,z]$ 之间。

每次修改包含三个整数 $x,y,z$，意思是把 $x$ 点的操作修改为 $y$，数值改为 $z$。

### 题解

考虑序列上如何用线段树维护，即如何合并两个区间，记录全 $1$ 的数和全 $0$ 的数通过区间后的答案，对于经过整个区间后变成 $1$ 的位，只有两种可能，在经过左区间后是 $1$，经过右区间后仍是 $1$；经过左区间是 $0$，经过右区间后变为 $1$，即 $ans_0=(l_0 \operatorname{bitand} r_1)\operatorname{bitor}(\operatorname{compl} l_0\operatorname{bitand}r_0),ans_1=(l_1 \operatorname{bitand} r_1)\operatorname{bitor}(\operatorname{compl} l_1\operatorname{bitand}r_0)$。直接上树剖加线段树，LCT，全局平衡二叉树都行。

## [Ynoi2017] 由乃的玉米田

### 题意

给你一个序列 $a$，长度为 $n$，有 $m$ 次操作，每次询问一个区间是否可以选出两个数它们的差为 $x$，或者询问一个区间是否可以选出两个数它们的和为 $x$，或者询问一个区间是否可以选出两个数它们的乘积为 $x$，或者询问一个区间是否可以选出两个数它们的商为 $x$（没有余数），这四个操作分别为操作 $1,2,3,4$。

### 题解

对于前两个，直接莫队加 `bitset`。对于第三个，莫队加 `bitset` 暴力枚举因数。对于第四个，如果 $x\ge \sqrt n$，莫队加 `bitset` 暴力枚举倍数；否则对于每一个 $x$，扫一遍序列处理。

## [Ynoi2017] 由乃打扑克

### 题意

给定一个序列，操作：

- 区间 $[l,r]$ 加上 $k$；
- 求区间第 $k$ 小值。

### 题解

分块，块内存排序数组，然后二分，再卡卡常。

当然，多序列二分可以用分散层叠优化。

## [Ynoi2018] 五彩斑斓的世界

### 题意

给定一个序列 $a$，操作：

- 把区间 $[l,r]$ 中大于 $x$ 的数减去 $x$；
- 查询区间 $[l,r]$ 中 $x$ 的出现次数。

### 题解

先分块，逐块处理，对于每块我们用并查集维护相同的值，设置区间减的 $\text{tag}$，并维护最大值 $k$。若 $2x\ge k$，把大于 $x$ 的数减去 $x$；否则，把小于等于 $x$ 的数加上 $x$，并让 $\text{tag}=\text{tag}+x$。

## [Ynoi2018] 未来日记

### 题意

给定一个序列 $a$，操作：

- 把区间 $[l,r]$ 中所有 $x$ 变成 $y$；
- 查询区间 $[l,r]$ 中的 $k$ 小值。

### 题解

序列分块，值域分块，并查集维护相同的值，值域分块 $O(\sqrt n)$ 查询 $k$ 小值，维护每一种数在每一块内的出现次数和前缀和，维护每一块数在每一块内的出现次数的前缀和。

## [Ynoi2018] 天降之物

### 题意

给定一个序列 $a$，操作：

- 把所有 $x$ 变成 $y$；
- 找出一个位置 $i$ 满足 $a_i=x$，找出一个位置 $j$ 满足 $a_j=y$，使得 $\mid i-j\mid$ 最小，并输出 $\mid i-j\mid$。

### 题解

使用 `vector` 存储每种元素的出现位置。根号分治，出现次数大于 $\sqrt n$ 的元素不超过 $\sqrt n$ 个，对这些元素预处理出它们和所有元素的答案，并不存储预处理过的位置，新增位置若不足 $\sqrt n$ 的也存到 `vector` 里，否则再次预处理，每次询问扫一遍 `vector` 即可。

## [Ynoi2018] GOSICK

### 题意

给定一个序列 $a$，每次询问给一个区间 $[l,r]$。查询 $l \leq i,j\leq r$，且 $a_i$ 是 $a_j$ 倍数的二元组 $(i,j)$ 的个数。

### 题解

莫队二次离线，显然只有在前缀 $[1,i]$ 中有多少个数是 $a_j$ 的倍数一种离线下来的询问不能 $O(\sqrt n)$ 插入 $O(1)$ 查询。考虑根号分治，对于大于 $\sqrt{\max\{a\}}$ 的显然可以暴力向倍数的位置贡献，复杂度正确；对于小于 $\sqrt{\max\{a\}}$ 的，我们的询问是 $O(m)$ 个形如在前缀 $[1,i]$ 中有多少个数是 $[l,r]$ 内数的倍数，这部分的答案是 $\sum\limits_{v=1}^{\sqrt{max\{a\}}}\left(\sum\limits_{j=1}^i[a_j=v]\right)\left(\sum\limits_{x=l}^r[a_x\equiv0\pmod v]\right)$。

## [Ynoi2019] 魔法少女网站

### 题意

给定一个序列，操作：

- 将 $x$ 位置的值修改为 $y$；
- 查询区间 $[l,r]$ 中有多少字区间的最大值小于等于 $x$。

### 题解

操作分块，对于同一块内的询问，按 $x$ 排序，被修改的位置单独处理，每次先修改，再遍历所有被修改的位置，计算答案，撤销影响。问题转化为有一个 $01$ 序列，两种操作，$O(1)$ 把 $0$ 变成 $1$，$O(\sqrt n)$ 查询在一个区间内，设极长连续的 $1$ 长度为 $i$，求 $\sum \frac{i(i+1)}{2}$。序列分块，维护极长连续段的头和尾，用链表维护相同的值的位置，对于每个询问，先加入所有小于 $x$ 的值，再处理被修改的位置 ，在一整块的询问处理完毕后，将修改的影响加到原序列上。

## [Ynoi2019] 美好的每一天~ 不连续的存在

### 题意

给定一个数组 $A$，以及一棵 $n$ 个节点的树，每个点有一个颜色，颜色为 $1$ 到 $x$ 的整数。每次查询树上只保留 $[l,r]$ 内的所有节点，设一个极大连通块中出现奇数次数的颜色个数为 $t$，则其对答案的贡献为 $A_t$，即答案是所有连通块贡献的和，询问间互相独立。

### 题解

注：这里回滚莫队的写法为同一块内暴力，右端点在同一块内的询问，按左端点排序。

考虑如何合并连通块，我使用的方法是压位 $\rm{trie}$（这个东西到底叫什么我也不太清楚）合并，显然复杂度是均摊的。考虑回滚莫队，如果不算回滚部分的复杂度，复杂度显然正确，均摊复杂度为 $O(n\log n)$，也就是说，我们必须让一个块内插入所有节点时总复杂度在 $O(\frac{n\log n}{\sqrt m})$ 内。考虑先模拟一遍最劣情况下的回滚，即左侧所有点都已插入，这时在插入这个点的时间消耗就是最劣情况，如果消耗大于 $O(\frac{n\log n}{\sqrt m})$，则将这个点作为新块的左端点，等价于对一个长为 $O(n\log n)$ 的序列分块。但单个点插入的复杂度可能远超 $O(\frac{n\log n}{\sqrt m})$，我们发现，这样的点一定是左端点，而在处理右端点在这个块内的询问的时候，所有询问必然包含这个点，我们直接在处理询问前将其设为存在的节点，这样插入这个点的复杂度便是 $O(1)$。