---
title: P7126 [Ynoi2008] rdCcot
tags: 数据结构 平衡树 点分治
---

我们有个 naive 的想法，预处理出和每个节点编号最接近的距离在 $C$ 以内的两个（一个大于 $x$，一个小于 $x$）节点，然后莫队并查集，于是你写了，过样例了，交了，WA 了。

冷静思考一下可以发现这种做法是显然错误的，我们注意到我们 $2n$ 个信息中有重复的，有用的信息没有记录下来，为了获取尽可能多的信息，我们对于编号为 $x$ 的点，记录编号最接近的两个距离在 $C$ 以内且满足 $dep_i<dep_x\lor(dep_i=dep_x\land i<x)$ 的点。

你感性理解一下就会发现这个东西很对，我也不会证明，如果有会的可以私信我，我会加进来。

我们注意数据范围，猜想正解复杂度为 $O(n\log^2 n+m\log n)$。

首先，预处理出上面说的这个东西可以用点分治，对于每一个分治中心，我们把点按 $dep$ 排序插入平衡树内，平衡树节点维护到分治中心的 $dis$ 最小值，查询时直接平衡树上二分就可以了。

然后考虑如何处理查询，我们可以把询问从数连通块变为数 $l_i<l\land r_i>r$ 的点数量，为什么这么做是正确的，这样的点肯定是连通块中深度最浅的点，若两个连通块间有连边，其中一个连通块深度最浅的点一定会有连另一个连通块的边，所以一个连通块中只有一个满足  $l_i<l\land r_i>r$ 的点。问题转化为每个点有两个属性 $l_i,r_i$，当 $l_i<l\land r_i>r$ 时，$i$ 对询问区间 $[l,r]$ 产生 $1$ 的贡献，直接把询问离线下来用树状数组维护答案就可以了，不会的可以去做 HH 的项链。

